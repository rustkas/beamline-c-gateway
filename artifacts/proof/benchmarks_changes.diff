diff --git a/benchmarks/bench_ipc_latency.c b/benchmarks/bench_ipc_latency.c
index 57fd9cc..87eebac 100644
--- a/benchmarks/bench_ipc_latency.c
+++ b/benchmarks/bench_ipc_latency.c
@@ -1,48 +1,68 @@
 /**
- * bench_ipc_latency.c - IPC latency percentile benchmark
+ * bench_ipc_latency.c - REAL IPC latency benchmark
  * 
- * Task 20: Measure p50, p95, p99 latency
+ * Uses actual ipc_protocol.h framing + warmup + payload size options
  */
 
 #define _GNU_SOURCE
+#include "ipc_protocol.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdint.h>
 #include <string.h>
+#include <stddef.h>
 #include <time.h>
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/un.h>
+#include <errno.h>
+#include <arpa/inet.h>
 
-#define IPC_SOCKET_PATH "/tmp/ipc_bench.sock"
+#define DEFAULT_SOCKET_PATH "/tmp/beamline-gateway.sock"
 #define DEFAULT_REQUESTS 10000
-#define MAX_SAMPLES 1000000
+#define WARMUP_REQUESTS 100
 
-/**
- * Simple IPC message format
- */
-typedef struct {
-    uint32_t magic;
-    uint32_t length;
-    uint8_t type;
-    uint8_t reserved[3];
-    char payload[256];
-} ipc_message_t;
+static char g_socket_path[256] = DEFAULT_SOCKET_PATH;
+static size_t g_payload_size = 64;  /* Default 64 bytes */
 
-#define IPC_MAGIC 0x49504300
+/* send_all/recv_all helpers */
+static ssize_t send_all(int sock, const void *buf, size_t len) {
+    const char *ptr = (const char*)buf;
+    size_t remaining = len;
+    while (remaining > 0) {
+        ssize_t sent = send(sock, ptr, remaining, MSG_NOSIGNAL);
+        if (sent < 0) {
+            if (errno == EINTR) continue;
+            return -1;
+        }
+        ptr += sent;
+        remaining -= (size_t)sent;
+    }
+    return (ssize_t)len;
+}
 
-/**
- * Get monotonic time in microseconds
- */
-static uint64_t get_time_us(void) {
+static ssize_t recv_all(int sock, void *buf, size_t len) {
+    char *ptr = (char*)buf;
+    size_t remaining = len;
+    while (remaining > 0) {
+        ssize_t received = recv(sock, ptr, remaining, 0);
+        if (received < 0) {
+            if (errno == EINTR) continue;
+            return -1;
+        }
+        if (received == 0) return 0;
+        ptr += received;
+        remaining -= (size_t)received;
+    }
+    return (ssize_t)len;
+}
+
+static uint64_t get_time_ns(void) {
     struct timespec ts;
     clock_gettime(CLOCK_MONOTONIC, &ts);
-    return (uint64_t)ts.tv_sec * 1000000 + (uint64_t)(ts.tv_nsec / 1000);
+    return (uint64_t)ts.tv_sec * 1000000000ULL + (uint64_t)ts.tv_nsec;
 }
 
-/**
- * Compare function for qsort
- */
 static int compare_uint64(const void *a, const void *b) {
     const uint64_t *va = (const uint64_t*)a;
     const uint64_t *vb = (const uint64_t*)b;
@@ -51,112 +71,169 @@ static int compare_uint64(const void *a, const void *b) {
     return 0;
 }
 
-/**
- * Calculate percentile
- */
 static uint64_t percentile(uint64_t *samples, size_t count, double p) {
     if (count == 0) return 0;
-    
     size_t index = (size_t)((double)count * p / 100.0);
     if (index >= count) index = count - 1;
-    
     return samples[index];
 }
 
-/**
- * Send IPC request and measure latency
- */
-static int measure_request(int sock, uint64_t *latency_us) {
-    ipc_message_t msg;
-    memset(&msg, 0, sizeof(msg));
+static int connect_ipc(void) {
+    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (sock < 0) return -1;
     
-    msg.magic = IPC_MAGIC;
-    msg.type = 1;
-    snprintf(msg.payload, sizeof(msg.payload), "latency_test");
-    msg.length = (uint32_t)strlen(msg.payload);
+    struct timeval tv = { .tv_sec = 10, .tv_usec = 0 };
+    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
+    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
     
-    /* Start timer */
-    uint64_t start = get_time_us();
+    struct sockaddr_un addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.sun_family = AF_UNIX;
+    strncpy(addr.sun_path, g_socket_path, sizeof(addr.sun_path) - 1);
     
-    /* Send request */
-    if (send(sock, &msg, sizeof(msg), 0) < 0) {
+    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
+        close(sock);
+        return -1;
+    }
+    return sock;
+}
+
+static int measure_request(int sock, uint64_t *latency_ns) {
+    /* Create message with payload */
+    char *payload = malloc(g_payload_size);
+    memset(payload, 'A', g_payload_size);
+    
+    ipc_message_t msg = {
+        .type = IPC_MSG_PING,
+        .payload = payload,
+        .payload_len = g_payload_size
+    };
+    
+    char frame_buf[IPC_MAX_FRAME_SIZE];
+    ssize_t frame_len = ipc_encode_message(&msg, frame_buf, sizeof(frame_buf));
+    free(payload);
+    
+    if (frame_len < 0) return -1;
+    
+    /* Measure round-trip */
+    uint64_t start = get_time_ns();
+    
+    if (send_all(sock, frame_buf, (size_t)frame_len) < 0) {
         return -1;
     }
     
     /* Receive response */
-    ipc_message_t response;
-    if (recv(sock, &response, sizeof(response), 0) < 0) {
+    char header[IPC_HEADER_SIZE];
+    if (recv_all(sock, header, IPC_HEADER_SIZE) != IPC_HEADER_SIZE) {
         return -1;
     }
     
-    /* Stop timer */
-    uint64_t end = get_time_us();
+    /* Validate response header */
+    uint32_t resp_len;
+    memcpy(&resp_len, header, 4);
+    resp_len = ntohl(resp_len);
     
-    *latency_us = end - start;
-    return 0;
-}
-
-/**
- * Connect to IPC server
- */
-static int connect_ipc(void) {
-    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
-    if (sock < 0) {
-        perror("socket");
+    if (resp_len < IPC_HEADER_SIZE || resp_len > IPC_MAX_FRAME_SIZE) {
+        fprintf(stderr, "ERROR: Invalid response frame length: %u\n", resp_len);
         return -1;
     }
     
-    struct sockaddr_un addr;
-    memset(&addr, 0, sizeof(addr));
-    addr.sun_family = AF_UNIX;
-    strncpy(addr.sun_path, IPC_SOCKET_PATH, sizeof(addr.sun_path) - 1);
+    /* Validate protocol version */
+    uint8_t resp_version = (uint8_t)header[4];
+    if (resp_version != IPC_PROTOCOL_VERSION) {
+        fprintf(stderr, "ERROR: Invalid response version: got 0x%02x, expected 0x%02x\n",
+                resp_version, IPC_PROTOCOL_VERSION);
+        return -1;
+    }
     
-    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
-        perror("connect");
-        close(sock);
+    /* Validate message type - accept RESPONSE_OK or PONG */
+    uint8_t resp_type = (uint8_t)header[5];
+    if (resp_type != IPC_MSG_RESPONSE_OK && resp_type != IPC_MSG_PONG) {
+        fprintf(stderr, "ERROR: Invalid response type: got 0x%02x, expected 0x%02x (RESPONSE_OK) or 0x%02x (PONG)\n",
+                resp_type, IPC_MSG_RESPONSE_OK, IPC_MSG_PONG);
         return -1;
     }
     
-    return sock;
+    size_t payload_len = resp_len - IPC_HEADER_SIZE;
+    if (payload_len > 0) {
+        char *resp_payload = malloc(payload_len);
+        if (recv_all(sock, resp_payload, payload_len) != (ssize_t)payload_len) {
+            free(resp_payload);
+            return -1;
+        }
+        free(resp_payload);
+    }
+    
+    uint64_t end = get_time_ns();
+    *latency_ns = end - start;
+    return 0;
 }
 
 int main(int argc, char *argv[]) {
     int num_requests = DEFAULT_REQUESTS;
+    int warmup = WARMUP_REQUESTS;
     
-    /* Parse arguments */
-    if (argc > 1) {
-        num_requests = atoi(argv[1]);
+    /* Parse args */
+    for (int i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-n") == 0 && i + 1 < argc) {
+            num_requests = atoi(argv[i + 1]);
+            i++;
+        } else if (strcmp(argv[i], "-s") == 0 && i + 1 < argc) {
+            /* CLI has highest priority - set immediately */
+            strncpy(g_socket_path, argv[i + 1], sizeof(g_socket_path) - 1);
+            g_socket_path[sizeof(g_socket_path) - 1] = '\0';
+            i++;
+        } else if (strcmp(argv[i], "-p") == 0 && i + 1 < argc) {
+            g_payload_size = (size_t)atoi(argv[i + 1]);
+            i++;
+        } else if (strcmp(argv[i], "--no-warmup") == 0) {
+            warmup = 0;
+        } else if (strcmp(argv[i], "-h") == 0) {
+            printf("Usage: %s [-n requests] [-s socket] [-p payload_size] [--no-warmup]\n", argv[0]);
+            printf("  -n: Number of requests (default: %d)\n", DEFAULT_REQUESTS);
+            printf("  -s: Socket path (default: %s)\n", DEFAULT_SOCKET_PATH);
+            printf("  -p: Payload size in bytes (default: 64)\n");
+            printf("  --no-warmup: Skip warmup phase\n");
+            return 0;
+        }
     }
     
-    if (num_requests < 1 || num_requests > MAX_SAMPLES) {
-        fprintf(stderr, "Invalid request count (1-%d)\n", MAX_SAMPLES);
-        return 1;
+    /* Apply ENV only if CLI didn't override (CLI > ENV > default) */
+    if (strcmp(g_socket_path, DEFAULT_SOCKET_PATH) == 0) {
+        const char *env_socket = getenv("IPC_SOCKET_PATH");
+        if (env_socket && env_socket[0]) {
+            strncpy(g_socket_path, env_socket, sizeof(g_socket_path) - 1);
+            g_socket_path[sizeof(g_socket_path) - 1] = '\0';
+        }
     }
     
-    printf("IPC Latency Benchmark\n");
-    printf("Requests: %d\n", num_requests);
-    printf("Socket: %s\n", IPC_SOCKET_PATH);
-    printf("\nConnecting to IPC server...\n");
+    printf("IPC Latency Benchmark (REAL PROTOCOL)\n");
+    printf("Requests:     %d\n", num_requests);
+    printf("Payload Size: %zu bytes\n", g_payload_size);
+    printf("Socket:       %s\n", g_socket_path);
+    printf("\nConnecting...\n");
     
-    /* Connect */
     int sock = connect_ipc();
     if (sock < 0) {
-        fprintf(stderr, "Failed to connect to IPC server\n");
+        fprintf(stderr, "ERROR: Cannot connect to %s\n", g_socket_path);
+        fprintf(stderr, "Make sure IPC gateway is running\n");
         return 1;
     }
     
-    printf("Connected. Running latency tests...\n");
-    
-    /* Allocate sample array */
-    uint64_t *latencies = malloc((size_t)num_requests * sizeof(uint64_t));
-    if (!latencies) {
-        fprintf(stderr, "Failed to allocate memory\n");
-        close(sock);
-        return 1;
+    /* Warmup */
+    if (warmup > 0) {
+        printf("Warming up (%d requests)...\n", warmup);
+        for (int i = 0; i < warmup; i++) {
+            uint64_t dummy;
+            measure_request(sock, &dummy);
+        }
     }
     
-    /* Run requests and measure latencies */
+    /* Measure */
+    printf("Running latency tests...\n");
+    uint64_t *latencies = malloc((size_t)num_requests * sizeof(uint64_t));
     int successful = 0;
+    
     for (int i = 0; i < num_requests; i++) {
         uint64_t latency;
         if (measure_request(sock, &latency) == 0) {
@@ -164,24 +241,21 @@ int main(int argc, char *argv[]) {
         }
         
         if ((i + 1) % 1000 == 0) {
-            printf("Progress: %d/%d requests\n", i + 1, num_requests);
+            printf("  Progress: %d/%d\n", i + 1, num_requests);
         }
     }
     
     close(sock);
     
     if (successful == 0) {
-        fprintf(stderr, "No successful requests\n");
+        fprintf(stderr, "ERROR: No successful requests\n");
         free(latencies);
         return 1;
     }
     
-    printf("\nCompleted %d/%d requests successfully\n", successful, num_requests);
-    
-    /* Sort latencies for percentile calculation */
+    /* Sort and calculate percentiles */
     qsort(latencies, (size_t)successful, sizeof(uint64_t), compare_uint64);
     
-    /* Calculate statistics */
     uint64_t min = latencies[0];
     uint64_t max = latencies[successful - 1];
     uint64_t p50 = percentile(latencies, (size_t)successful, 50.0);
@@ -189,30 +263,27 @@ int main(int argc, char *argv[]) {
     uint64_t p99 = percentile(latencies, (size_t)successful, 99.0);
     uint64_t p999 = percentile(latencies, (size_t)successful, 99.9);
     
-    /* Calculate mean */
     uint64_t sum = 0;
     for (int i = 0; i < successful; i++) {
         sum += latencies[i];
     }
-    double mean = (double)sum / (double)successful;
-    
-    /* Print results */
-    printf("\n=== IPC Latency Results ===\n");
-    printf("Requests:     %d\n", successful);
-    printf("Min:          %.3f ms\n", (double)min / 1000.0);
-    printf("Mean:         %.3f ms\n", mean / 1000.0);
-    printf("p50 (median): %.3f ms\n", (double)p50 / 1000.0);
-    printf("p95:          %.3f ms\n", (double)p95 / 1000.0);
-    printf("p99:          %.3f ms\n", (double)p99 / 1000.0);
-    printf("p99.9:        %.3f ms\n", (double)p999 / 1000.0);
-    printf("Max:          %.3f ms\n", (double)max / 1000.0);
-    printf("\n");
-    
-    /* Evaluate against targets */
-    if (p99 <= 10000) {  /* 10ms in microseconds */
-        printf("✅ EXCELLENT: p99 latency <= 10ms target\n");
+    double mean_ns = (double)sum / (double)successful;
+    
+    printf("\n=== Latency Results ===\n");
+    printf("Successful:   %d/%d\n", successful, num_requests);
+    printf("Payload Size: %zu bytes\n", g_payload_size);
+    printf("Min:          %.3f ms\n", (double)min / 1000000.0);
+    printf("Mean:         %.3f ms\n", mean_ns / 1000000.0);
+    printf("p50 (median): %.3f ms\n", (double)p50 / 1000000.0);
+    printf("p95:          %.3f ms\n", (double)p95 / 1000000.0);
+    printf("p99:          %.3f ms\n", (double)p99 / 1000000.0);
+    printf("p99.9:        %.3f ms\n", (double)p999 / 1000000.0);
+    printf("Max:          %.3f ms\n", (double)max / 1000000.0);
+    
+    if (p99 <= 10000000ULL) {  /* 10ms */
+        printf("\n✅ EXCELLENT: p99 <= 10ms\n");
     } else {
-        printf("⚠️  WARNING: p99 latency > 10ms target\n");
+        printf("\n⚠️  WARNING: p99 > 10ms\n");
     }
     
     free(latencies);
diff --git a/benchmarks/bench_ipc_throughput.c b/benchmarks/bench_ipc_throughput.c
index f2fe0f1..ae05957 100644
--- a/benchmarks/bench_ipc_throughput.c
+++ b/benchmarks/bench_ipc_throughput.c
@@ -1,10 +1,11 @@
 /**
- * bench_ipc_throughput.c - IPC throughput benchmark
+ * bench_ipc_throughput.c - REAL IPC throughput benchmark
  * 
- * Task 20: Measure sustained requests/second
+ * Uses actual ipc_protocol.h framing
  */
 
 #define _GNU_SOURCE
+#include "ipc_protocol.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdint.h>
@@ -15,10 +16,14 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <stdatomic.h>
+#include <errno.h>
+#include <arpa/inet.h>
 
-#define IPC_SOCKET_PATH "/tmp/ipc_bench.sock"
-#define DEFAULT_DURATION 10  /* seconds */
+/* Default socket path - can override with env or -s */
+#define DEFAULT_SOCKET_PATH "/tmp/beamline-gateway.sock"
+#define DEFAULT_DURATION 10
 #define DEFAULT_THREADS 4
+#define DEFAULT_WARMUP_REQUESTS 100
 
 /* Atomic counters */
 static atomic_ulong g_requests_sent = 0;
@@ -26,44 +31,105 @@ static atomic_ulong g_requests_completed = 0;
 static atomic_ulong g_requests_failed = 0;
 static atomic_int g_running = 1;
 
+/* Socket path (configurable) */
+static char g_socket_path[256] = DEFAULT_SOCKET_PATH;
+static size_t g_payload_size = 2;  /* Default: "{}" */
+static int g_warmup_requests = DEFAULT_WARMUP_REQUESTS;
+
 /**
- * Simple IPC message format (minimal for benchmark)
+ * send_all - ensure all bytes are sent
  */
-typedef struct {
-    uint32_t magic;      /* 0x49504300 */
-    uint32_t length;     /* Payload length */
-    uint8_t type;        /* Message type */
-    uint8_t reserved[3];
-    char payload[256];
-} ipc_message_t;
+static ssize_t send_all(int sock, const void *buf, size_t len) {
+    const char *ptr = (const char*)buf;
+    size_t remaining = len;
+    
+    while (remaining > 0) {
+        ssize_t sent = send(sock, ptr, remaining, MSG_NOSIGNAL);
+        if (sent < 0) {
+            if (errno == EINTR) continue;
+            return -1;
+        }
+        ptr += sent;
+        remaining -= (size_t)sent;
+    }
+    return (ssize_t)len;
+}
 
-#define IPC_MAGIC 0x49504300
+/**
+ * recv_all - ensure all bytes are received
+ */
+static ssize_t recv_all(int sock, void *buf, size_t len) {
+    char *ptr = (char*)buf;
+    size_t remaining = len;
+    
+    while (remaining > 0) {
+        ssize_t received = recv(sock, ptr, remaining, 0);
+        if (received < 0) {
+            if (errno == EINTR) continue;
+            return -1;
+        }
+        if (received == 0) return 0;  /* EOF */
+        ptr += received;
+        remaining -= (size_t)received;
+    }
+    return (ssize_t)len;
+}
 
 /**
- * Send a simple IPC request
+ * Send IPC request using real protocol
  */
 static int send_ipc_request(int sock) {
-    ipc_message_t msg;
-    memset(&msg, 0, sizeof(msg));
+    /* Create PING message with configurable payload */
+    char *payload = malloc(g_payload_size);
+    if (!payload) return -1;
+    memset(payload, 'A', g_payload_size);
+    
+    ipc_message_t msg = {
+        .type = IPC_MSG_PING,
+        .payload = payload,
+        .payload_len = g_payload_size
+    };
+    
+    /* Encode to frame */
+    char frame_buf[IPC_MAX_FRAME_SIZE];
+    ssize_t frame_len = ipc_encode_message(&msg, frame_buf, sizeof(frame_buf));
+    free(payload);
+    
+    if (frame_len < 0) {
+        return -1;
+    }
     
-    msg.magic = IPC_MAGIC;
-    msg.type = 1;  /* REQUEST */
-    snprintf(msg.payload, sizeof(msg.payload), "benchmark");
-    msg.length = (uint32_t)strlen(msg.payload);
+    /* Send frame */
+    if (send_all(sock, frame_buf, (size_t)frame_len) < 0) {
+        return -1;
+    }
     
-    /* Send request */
-    ssize_t sent = send(sock, &msg, sizeof(msg), 0);
-    if (sent < 0) {
+    /* Receive response header */
+    char header[IPC_HEADER_SIZE];
+    if (recv_all(sock, header, IPC_HEADER_SIZE) != IPC_HEADER_SIZE) {
         return -1;
     }
     
-    /* Receive response (simple echo) */
-    ipc_message_t response;
-    ssize_t received = recv(sock, &response, sizeof(response), 0);
-    if (received < 0) {
+    /* Parse length */
+    uint32_t frame_length;
+    memcpy(&frame_length, header, 4);
+    frame_length = ntohl(frame_length);
+    
+    if (frame_length < IPC_HEADER_SIZE || frame_length > IPC_MAX_FRAME_SIZE) {
         return -1;
     }
     
+    /* Receive remaining payload */
+    size_t payload_len = frame_length - IPC_HEADER_SIZE;
+    if (payload_len > 0) {
+        char *payload = malloc(payload_len);
+        if (recv_all(sock, payload, payload_len) != (ssize_t)payload_len) {
+            free(payload);
+            return -1;
+        }
+        free(payload);
+    }
+    
     return 0;
 }
 
@@ -73,17 +139,20 @@ static int send_ipc_request(int sock) {
 static int connect_ipc(void) {
     int sock = socket(AF_UNIX, SOCK_STREAM, 0);
     if (sock < 0) {
-        perror("socket");
         return -1;
     }
     
+    /* Set receive timeout */
+    struct timeval tv = { .tv_sec = 5, .tv_usec = 0 };
+    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
+    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
+    
     struct sockaddr_un addr;
     memset(&addr, 0, sizeof(addr));
     addr.sun_family = AF_UNIX;
-    strncpy(addr.sun_path, IPC_SOCKET_PATH, sizeof(addr.sun_path) - 1);
+    strncpy(addr.sun_path, g_socket_path, sizeof(addr.sun_path) - 1);
     
     if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
-        perror("connect");
         close(sock);
         return -1;
     }
@@ -92,19 +161,19 @@ static int connect_ipc(void) {
 }
 
 /**
- * Worker thread - sends requests continuously
+ * Worker thread
  */
 static void* worker_thread(void* arg) {
     (void)arg;
     
-    /* Connect to IPC server */
+    /* Connect */
     int sock = connect_ipc();
     if (sock < 0) {
-        fprintf(stderr, "[worker] Failed to connect to IPC server\n");
+        fprintf(stderr, "[worker] Failed to connect\n");
         return NULL;
     }
     
-    /* Send requests until stopped */
+    /* Send requests */
     while (atomic_load(&g_running)) {
         atomic_fetch_add(&g_requests_sent, 1);
         
@@ -119,37 +188,6 @@ static void* worker_thread(void* arg) {
     return NULL;
 }
 
-/**
- * Print results
- */
-static void print_results(int duration, int num_threads) {
-    unsigned long sent = atomic_load(&g_requests_sent);
-    unsigned long completed = atomic_load(&g_requests_completed);
-    unsigned long failed = atomic_load(&g_requests_failed);
-    
-    double throughput = (double)completed / (double)duration;
-    double success_rate = sent > 0 ? ((double)completed / (double)sent * 100.0) : 0.0;
-    
-    printf("\n");
-    printf("=== IPC Throughput Benchmark Results ===\n");
-    printf("Duration:          %d seconds\n", duration);
-    printf("Threads:           %d\n", num_threads);
-    printf("Total Sent:        %lu requests\n", sent);
-    printf("Completed:         %lu requests\n", completed);
-    printf("Failed:            %lu requests\n", failed);
-    printf("Throughput:        %.0f req/sec\n", throughput);
-    printf("Success Rate:      %.2f%%\n", success_rate);
-    printf("\n");
-    
-    if (throughput < 1000) {
-        printf("⚠️  WARNING: Throughput below 1,000 req/sec\n");
-    } else if (throughput >= 5000) {
-        printf("✅ EXCELLENT: Throughput >= 5,000 req/sec target\n");
-    } else {
-        printf("✓ GOOD: Throughput acceptable\n");
-    }
-}
-
 int main(int argc, char *argv[]) {
     int duration = DEFAULT_DURATION;
     int num_threads = DEFAULT_THREADS;
@@ -162,51 +200,100 @@ int main(int argc, char *argv[]) {
         } else if (strcmp(argv[i], "-t") == 0 && i + 1 < argc) {
             num_threads = atoi(argv[i + 1]);
             i++;
+        } else if (strcmp(argv[i], "-s") == 0 && i + 1 < argc) {
+            strncpy(g_socket_path, argv[i + 1], sizeof(g_socket_path) - 1);
+            g_socket_path[sizeof(g_socket_path) - 1] = '\0';
+            i++;
+        } else if (strcmp(argv[i], "-p") == 0 && i + 1 < argc) {
+            g_payload_size = (size_t)atoi(argv[i + 1]);
+            i++;
         } else if (strcmp(argv[i], "-h") == 0) {
-            printf("Usage: %s [-d duration] [-t threads]\n", argv[0]);
+            printf("Usage: %s [-d duration] [-t threads] [-s socket]\n", argv[0]);
             printf("  -d: Duration in seconds (default: %d)\n", DEFAULT_DURATION);
             printf("  -t: Number of threads (default: %d)\n", DEFAULT_THREADS);
+            printf("  -s: Socket path (default: %s or $IPC_SOCKET_PATH)\n", DEFAULT_SOCKET_PATH);
             return 0;
         }
     }
     
-    if (duration < 1) duration = 1;
-    if (num_threads < 1) num_threads = 1;
+    /* Apply ENV only if CLI didn't override (CLI > ENV > default) */
+    if (strcmp(g_socket_path, DEFAULT_SOCKET_PATH) == 0) {
+        const char *env_socket = getenv("IPC_SOCKET_PATH");
+        if (env_socket && env_socket[0]) {
+            strncpy(g_socket_path, env_socket, sizeof(g_socket_path) - 1);
+            g_socket_path[sizeof(g_socket_path) - 1] = '\0';
+        }
+    }
     
-    printf("IPC Throughput Benchmark\n");
+    printf("IPC Throughput Benchmark (REAL PROTOCOL)\n");
     printf("Duration: %d seconds, Threads: %d\n", duration, num_threads);
-    printf("Socket: %s\n", IPC_SOCKET_PATH);
-    printf("\nStarting benchmark...\n");
+    printf("Warmup: %d requests\n", g_warmup_requests);
+    printf("Socket: %s\n", g_socket_path);
+    printf("\n");
     
-    /* Create worker threads */
-    pthread_t *threads = malloc((size_t)num_threads * sizeof(pthread_t));
-    if (!threads) {
-        fprintf(stderr, "Failed to allocate threads\n");
-        return 1;
+    /* Warmup phase */
+    if (g_warmup_requests > 0) {
+        printf("=== Warmup Phase ===\n");
+        int warmup_sock = connect_ipc();
+        if (warmup_sock < 0) {
+            fprintf(stderr, "Failed to connect for warmup\n");
+            return 1;
+        }
+        
+        for (int i = 0; i < g_warmup_requests; i++) {
+            send_ipc_request(warmup_sock);
+        }
+        close(warmup_sock);
+        printf("Warmup complete: %d requests\n", g_warmup_requests);
+        printf("\n");
     }
     
+    /* Spawn worker threads */
+    printf("Starting benchmark...\n");
+    
+    /* Create threads */
+    pthread_t *threads = malloc((size_t)num_threads * sizeof(pthread_t));
     for (int i = 0; i < num_threads; i++) {
         if (pthread_create(&threads[i], NULL, worker_thread, NULL) != 0) {
-            fprintf(stderr, "Failed to create thread %d\n", i);
+            fprintf(stderr, "Failed to create thread\n");
             return 1;
         }
     }
     
-    /* Run for specified duration */
+    /* Run */
     sleep((unsigned int)duration);
-    
-    /* Stop workers */
     atomic_store(&g_running, 0);
     
-    /* Wait for threads */
+    /* Wait */
     for (int i = 0; i < num_threads; i++) {
         pthread_join(threads[i], NULL);
     }
-    
     free(threads);
     
-    /* Print results */
-    print_results(duration, num_threads);
+    /* Results */
+    unsigned long sent = atomic_load(&g_requests_sent);
+    unsigned long completed = atomic_load(&g_requests_completed);
+    unsigned long failed = atomic_load(&g_requests_failed);
+    
+    double throughput = (double)completed / (double)duration;
+    double success_rate = sent > 0 ? ((double)completed / (double)sent * 100.0) : 0.0;
+    
+    printf("\n=== Results ===\n");
+    printf("Duration:       %d seconds\n", duration);
+    printf("Threads:        %d\n", num_threads);
+    printf("Sent:           %lu\n", sent);
+    printf("Completed:      %lu\n", completed);
+    printf("Failed:         %lu\n", failed);
+    printf("Throughput:     %.0f req/sec\n", throughput);
+    printf("Success Rate:   %.2f%%\n", success_rate);
+    
+    if (throughput >= 5000) {
+        printf("\n✅ EXCELLENT: >= 5,000 req/sec\n");
+    } else if (throughput >= 1000) {
+        printf("\n✓ GOOD: >= 1,000 req/sec\n");
+    } else {
+        printf("\n⚠️  WARNING: < 1,000 req/sec\n");
+    }
     
     return 0;
 }
diff --git a/benchmarks/bench_memory.c b/benchmarks/bench_memory.c
index e64c3bc..cd9bace 100644
--- a/benchmarks/bench_memory.c
+++ b/benchmarks/bench_memory.c
@@ -1,75 +1,193 @@
 /**
- * bench_memory.c - Memory usage benchmark wrapper
+ * bench_memory.c - IPC Memory usage benchmark
  * 
- * Task 20: Track memory usage under load
+ * Measures RSS/FD stability under continuous IPC load
+ * Uses ipc_protocol.h for framing (single source of truth)
  */
 
+#define _GNU_SOURCE
+#include "ipc_protocol.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/time.h>
+#include <errno.h>
+#include <arpa/inet.h>
+#include <time.h>
+#include <inttypes.h>
+#include <dirent.h>
 
-/**
- * Read RSS (Resident Set Size) from /proc/self/status
- */
+#define DEFAULT_SOCKET_PATH "/tmp/beamline-gateway.sock"
+#define DEFAULT_REQUESTS 10000
+#define SAMPLE_INTERVAL 100
+#define IO_TIMEOUT_SEC 10
+
+/* RSS measurement */
 static long get_rss_kb(void) {
     FILE *f = fopen("/proc/self/status", "r");
     if (!f) return -1;
     
     char line[256];
-    long rss = -1;
-    
+    long rss_kb = -1;
     while (fgets(line, sizeof(line), f)) {
         if (strncmp(line, "VmRSS:", 6) == 0) {
-            sscanf(line + 6, "%ld", &rss);
+            sscanf(line + 6, "%ld", &rss_kb);
             break;
         }
     }
-    
     fclose(f);
-    return rss;
+    return rss_kb;
 }
 
-int main(int argc, char *argv[]) {
-    (void)argc;
-    (void)argv;
+/* FD count */
+static int count_open_fds(void) {
+    DIR *d = opendir("/proc/self/fd");
+    if (!d) return -1;
+    
+    int count = 0;
+    struct dirent *entry;
+    while ((entry = readdir(d)) != NULL) {
+        if (entry->d_name[0] != '.') count++;
+    }
+    closedir(d);
+    return count - 1; /* exclude /proc/self/fd itself */
+}
+
+/* Socket connection */
+static int connect_socket(const char *path) {
+    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (sock < 0) return -1;
     
-    printf("Memory Benchmark for IPC Gateway\n");
-    printf("=================================\n\n");
+    struct timeval tv = { .tv_sec = IO_TIMEOUT_SEC, .tv_usec = 0 };
+    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
+    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
     
-    printf("This benchmark should be run with memory profiling tools:\n\n");
+    struct sockaddr_un addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.sun_family = AF_UNIX;
+    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
     
-    printf("1. Valgrind (Memory leak detection):\n");
-    printf("   valgrind --leak-check=full ./build/ipc-gateway\n\n");
+    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
+        close(sock);
+        return -1;
+    }
     
-    printf("2. Massif (Heap profiling):\n");
-    printf("   valgrind --tool=massif ./build/ipc-gateway\n");
-    printf("   ms_print massif.out.<pid>\n\n");
+    return sock;
+}
+
+int main(int argc, char *argv[]) {
+    const char *socket_path = DEFAULT_SOCKET_PATH;
+    uint32_t requests = DEFAULT_REQUESTS;
     
-    printf("3. Heaptrack (Advanced heap profiling):\n");
-    printf("   heaptrack ./build/ipc-gateway\n");
-    printf("   heaptrack_gui heaptrack.<pid>.gz\n\n");
+    /* Parse args - PRIORITY: CLI > ENV > default */
+    if (argc > 1) socket_path = argv[1];
+    if (argc > 2) requests = (uint32_t)atoi(argv[2]);
     
-    printf("4. RSS monitoring during load test:\n");
-    printf("   ./build/ipc-gateway &\n");
-    printf("   watch -n 1 'ps aux | grep ipc-gateway'\n");
-    printf("   ./benchmarks/bench_ipc_throughput -d 60\n\n");
+    /* ENV only if CLI didn't override */
+    if (argc <= 1) {
+        const char *env = getenv("IPC_SOCKET_PATH");
+        if (env && env[0]) socket_path = env;
+    }
     
-    /* Also provide a simple RSS tracker */
-    printf("Simple RSS Monitor\n");
-    printf("------------------\n");
+    printf("IPC Memory Benchmark\n");
+    printf("socket: %s\n", socket_path);
+    printf("requests: %" PRIu32 "\n", requests);
+    printf("sample_interval: %d\n\n", SAMPLE_INTERVAL);
     
+    /* Baseline */
     long rss_baseline = get_rss_kb();
-    if (rss_baseline > 0) {
-        printf("Current RSS: %ld KB (%.1f MB)\n", rss_baseline, (double)rss_baseline / 1024.0);
-    } else {
-        printf("Failed to read RSS (not Linux?)\n");
+    int fd_baseline = count_open_fds();
+    
+    printf("Baseline RSS: %ld KB (%.1f MB)\n", rss_baseline, (double)rss_baseline / 1024.0);
+    printf("Baseline FDs: %d\n\n", fd_baseline);
+    
+    /* Connect */
+    int sock = connect_socket(socket_path);
+    if (sock < 0) {
+        fprintf(stderr, "Failed to connect to %s\n", socket_path);
+        return 1;
+    }
+    
+    /* Prepare message using ipc_protocol.h */
+    const char *payload_str = "{\"command\":\"memory_test\"}";
+    ipc_message_t msg = {
+        .type = IPC_MSG_PING,
+        .payload = (char*)payload_str,
+        .payload_len = strlen(payload_str)
+    };
+    
+    char frame_buf[IPC_MAX_FRAME_SIZE];
+    char resp_buf[IPC_MAX_FRAME_SIZE];
+    
+    long max_rss = rss_baseline;
+    int max_fd = fd_baseline;
+    
+    /* Run requests with sampling */
+    for (uint32_t i = 0; i < requests; i++) {
+        /* Encode and send using ipc_protocol.h */
+        ssize_t frame_len = ipc_encode_message(&msg, frame_buf, sizeof(frame_buf));
+        if (frame_len < 0) {
+            fprintf(stderr, "Encode failed at %" PRIu32 "\n", i);
+            break;
+        }
+        
+        if (send(sock, frame_buf, (size_t)frame_len, MSG_NOSIGNAL) != frame_len) {
+            fprintf(stderr, "Send failed at %" PRIu32 "\n", i);
+            break;
+        }
+        
+        /* Receive response - read header first */
+        char header[IPC_HEADER_SIZE];
+        ssize_t n = recv(sock, header, IPC_HEADER_SIZE, 0);
+        if (n != IPC_HEADER_SIZE) {
+            fprintf(stderr, "Recv header failed at %" PRIu32 "\n", i);
+            break;
+        }
+        
+        /* Parse length */
+        uint32_t resp_len;
+        memcpy(&resp_len, header, 4);
+        resp_len = ntohl(resp_len);
+        
+        if (resp_len > IPC_HEADER_SIZE && resp_len < IPC_MAX_FRAME_SIZE) {
+            size_t payload_len = resp_len - IPC_HEADER_SIZE;
+            if (recv(sock, resp_buf, payload_len, 0) != (ssize_t)payload_len) {
+                fprintf(stderr, "Recv payload failed at %" PRIu32 "\n", i);
+                break;
+            }
+        }
+        
+        if (i % SAMPLE_INTERVAL == 0) {
+            long rss = get_rss_kb();
+            int fds = count_open_fds();
+            
+            if (rss > max_rss) max_rss = rss;
+            if (fds > max_fd) max_fd = fds;
+            
+            printf("[%6" PRIu32 "] RSS: %6ld KB  FDs: %3d\n", i, rss, fds);
+        }
     }
     
-    printf("\nExpected behavior under load:\n");
-    printf("- Baseline RSS: ~10-20 MB\n");
-    printf("- Under load RSS: < 50 MB\n");
-    printf("- After load RSS: Should return to near baseline (no major leaks)\n");
+    close(sock);
+    
+    /* Final */
+    sleep(1);
+    long rss_final = get_rss_kb();
+    int fd_final = count_open_fds();
+    
+    printf("\nSummary:\n");
+    printf("  Baseline RSS:  %ld KB (%.1f MB)\n", rss_baseline, (double)rss_baseline / 1024.0);
+    printf("  Peak RSS:      %ld KB (%.1f MB)\n", max_rss, (double)max_rss / 1024.0);
+    printf("  Final RSS:     %ld KB (%.1f MB)\n", rss_final, (double)rss_final / 1024.0);
+    printf("  RSS Growth:    %ld KB (%.1f MB)\n", max_rss - rss_baseline, (double)(max_rss - rss_baseline) / 1024.0);
+    printf("\n");
+    printf("  Baseline FDs:  %d\n", fd_baseline);
+    printf("  Peak FDs:      %d\n", max_fd);
+    printf("  Final FDs:     %d\n", fd_final);
+    printf("  FD Growth:     %d\n", max_fd - fd_baseline);
     
     return 0;
 }
